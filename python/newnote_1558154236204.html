<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-09304d59-48ca-4962-8d0b-aff80e622b9e"></attachment><p>#include &lt;cv.h&gt;</p><p>#include &lt;cxcore.h&gt;</p><p>#include &lt;highgui.h&gt;</p><p><br></p><p>#include &lt;cmath&gt;</p><p>#include &lt;vector&gt;</p><p>#include &lt;iostream&gt;</p><p>using namespace std;</p><p><br></p><p>const int winHeight=600;</p><p>const int winWidth=800;</p><p><br></p><p><br></p><p>CvPoint mousePosition=cvPoint(winWidth&gt;&gt;1,winHeight&gt;&gt;1);</p><p><br></p><p>//mouse event callback</p><p>void mouseEvent(int event, int x, int y, int flags, void *param )</p><p>{</p><p>	if (event==CV_EVENT_MOUSEMOVE) {</p><p>		mousePosition=cvPoint(x,y);</p><p>	}</p><p>}</p><p><br></p><p>int main (void)</p><p>{</p><p>	//1.kalman filter setup</p><p>	const int stateNum=4;</p><p>	const int measureNum=2;</p><p>	CvKalman* kalman = cvCreateKalman( stateNum, measureNum, 0 );//state(x,y,detaX,detaY)</p><p>	CvMat* process_noise = cvCreateMat( stateNum, 1, CV_32FC1 );</p><p>	CvMat* measurement = cvCreateMat( measureNum, 1, CV_32FC1 );//measurement(x,y)</p><p>	CvRNG rng = cvRNG(-1);</p><p>	float A[stateNum][stateNum] ={//transition matrix</p><p>		1,0,1,0,</p><p>		0,1,0,1,</p><p>		0,0,1,0,</p><p>		0,0,0,1</p><p>	};</p><p><br></p><p>	memcpy( kalman-&gt;transition_matrix-&gt;data.fl,A,sizeof(A));</p><p>	cvSetIdentity(kalman-&gt;measurement_matrix,cvRealScalar(1) );</p><p>	cvSetIdentity(kalman-&gt;process_noise_cov,cvRealScalar(1e-5));</p><p>	cvSetIdentity(kalman-&gt;measurement_noise_cov,cvRealScalar(1e-1));</p><p>	cvSetIdentity(kalman-&gt;error_cov_post,cvRealScalar(1));</p><p>	//initialize post state of kalman filter at random</p><p>	cvRandArr(&amp;rng,kalman-&gt;state_post,CV_RAND_UNI,cvRealScalar(0),cvRealScalar(winHeight&gt;winWidth?winWidth:winHeight));</p><p><br></p><p>	CvFont font;</p><p>	cvInitFont(&amp;font,CV_FONT_HERSHEY_SCRIPT_COMPLEX,1,1);</p><p><br></p><p>	cvNamedWindow("kalman");</p><p>	cvSetMouseCallback("kalman",mouseEvent);</p><p>	IplImage* img=cvCreateImage(cvSize(winWidth,winHeight),8,3);</p><p>	while (1){</p><p>		//2.kalman prediction</p><p>		const CvMat* prediction=cvKalmanPredict(kalman,0);</p><p>		CvPoint predict_pt=cvPoint((int)prediction-&gt;data.fl[0],(int)prediction-&gt;data.fl[1]);</p><p><br></p><p>		//3.update measurement</p><p>		measurement-&gt;data.fl[0]=(float)mousePosition.x;</p><p>		measurement-&gt;data.fl[1]=(float)mousePosition.y;</p><p><br></p><p>		//4.update</p><p>		cvKalmanCorrect( kalman, measurement );		</p><p><br></p><p>		//draw&nbsp;</p><p>		cvSet(img,cvScalar(255,255,255,0));</p><p>		cvCircle(img,predict_pt,5,CV_RGB(0,255,0),3);//predicted point with green</p><p>		cvCircle(img,mousePosition,5,CV_RGB(255,0,0),3);//current position with red</p><p>		char buf[256];</p><p>		sprintf_s(buf,256,"predicted position:(%3d,%3d)",predict_pt.x,predict_pt.y);</p><p>		cvPutText(img,buf,cvPoint(10,30),&amp;font,CV_RGB(0,0,0));</p><p>		sprintf_s(buf,256,"current position :(%3d,%3d)",mousePosition.x,mousePosition.y);</p><p>		cvPutText(img,buf,cvPoint(10,60),&amp;font,CV_RGB(0,0,0));</p><p>		</p><p>		cvShowImage("kalman", img);</p><p>		int key=cvWaitKey(3);</p><p>		if (key==27){//esc&nbsp;&nbsp;</p><p>			break;&nbsp;&nbsp;</p><p>		}</p><p>	}&nbsp;&nbsp;&nbsp;&nbsp;</p><p><br></p><p>	cvReleaseImage(&amp;img);</p><p>	cvReleaseKalman(&amp;kalman);</p><p>	return 0;</p><p>}</p><p><br></p>